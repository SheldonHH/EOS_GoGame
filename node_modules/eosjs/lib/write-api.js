'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var assert = require('assert');
var ecc = require('eosjs-ecc');
var Fcbuffer = require('fcbuffer');
var createHash = require('create-hash');

var _require = require('eosjs-api'),
    processArgs = _require.processArgs;

var Structs = require('./structs');

module.exports = writeApiGen;

var sign = ecc.sign;


function writeApiGen(Network, network, structs, config) {

  if (typeof config.chainId !== 'string') {
    throw new TypeError('config.chainId is required');
  }

  var writeApi = WriteApi(Network, network, config, structs.transaction);
  var reserveFunctions = new Set(['transaction', 'contract']);
  var merge = {};

  // sends transactions, also a message collecting wrapper functions 
  merge.transaction = writeApi.genTransaction(structs, merge);

  // Immediate send operations automatically calls merge.transaction
  for (var type in Network.schema) {
    if (!/^[a-z]/.test(type)) {
      // Only lower case structs will work in a transaction message
      // See eosjs-json generated.json
      continue;
    }
    if (type === 'transaction') {
      continue; // https://github.com/EOSIO/eos/issues/730
    }
    if (reserveFunctions.has(type)) {
      throw new TypeError('Conflicting Api function: ' + type);
    }

    var struct = structs[type];
    var definition = Network.schema[type];
    merge[type] = writeApi.genMethod(type, definition, struct, merge.transaction);
  }

  /**
    Immedate send contract actions.
     @example eos.contract('mycontract', [options], [callback])
    @example eos.contract('mycontract').then(mycontract => mycontract.action(...))
  */
  merge.contract = function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _processArgs = processArgs(args, ['code'], 'contract', optionsFormatter),
        params = _processArgs.params,
        options = _processArgs.options,
        returnPromise = _processArgs.returnPromise,
        callback = _processArgs.callback;

    var code = params.code;

    // sends transactions via its own transaction function

    writeApi.genContractActions(code).then(function (r) {
      callback(null, r);
    }).catch(function (r) {
      callback(r);
    });

    return returnPromise;
  };

  return merge;
}

function WriteApi(Network, network, config, Transaction) {
  /**
    @arg {array} [args.contracts]
    @arg {callback|object} args.transaction tr => {tr.transfer .. }
    @arg {object} [args.options]
    @arg {function} [args.callback]
  */
  var genTransaction = function genTransaction(structs, merge) {
    return function () {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      var contracts = void 0,
          options = void 0,
          callback = void 0;

      if (args[args.length - 1] == null) {
        // callback may be undefined
        args = args.slice(0, args.length - 1);
      }

      var isContractArray = isStringArray(args[0]);
      if (isContractArray) {
        contracts = args[0];
        args = args.slice(1);
      } else if (typeof args[0] === 'string') {
        contracts = [args[0]];
        args = args.slice(1);
      }

      if (args.length > 1 && typeof args[args.length - 1] === 'function') {
        callback = args.pop();
      }

      if (args.length > 1 && _typeof(args[args.length - 1]) === 'object') {
        options = args.pop();
      }

      assert.equal(args.length, 1, 'transaction args: [contracts], transaction<callback|object>, [options], [callback]');
      var arg = args[0];

      if (contracts) {
        assert(!callback, 'callback with contracts are not supported');
        assert.equal('function', typeof arg === 'undefined' ? 'undefined' : _typeof(arg), 'provide function callback following contracts array parameter');

        var contractPromises = [];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = contracts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var code = _step.value;

            // setup wrapper functions to collect contract api calls
            contractPromises.push(genContractActions(code, merge.transaction));
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return Promise.all(contractPromises).then(function (actions) {
          var merges = {};
          actions.forEach(function (m, i) {
            merges[contracts[i]] = m;
          });
          var param = isContractArray ? merges : merges[contracts[0]];
          // collect and invoke api calls
          return trMessageCollector(arg, options, param);
        });
      }

      if (typeof arg === 'function') {
        return trMessageCollector(arg, options, merge);
      }

      if ((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object') {
        return transaction(arg, options, callback);
      }

      throw new Error('first transaction argument unrecognized', arg);
    };
  };

  function genContractActions(code) {
    var transaction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    return config.abiCache.abiAsync(code).then(function (cache) {
      assert(Array.isArray(cache.abi.actions) && cache.abi.actions.length, 'No actions');

      var contractMerge = {};
      contractMerge.transaction = transaction ? transaction : genTransaction(cache.structs, contractMerge);

      cache.abi.actions.forEach(function (_ref) {
        var action_name = _ref.action_name,
            type = _ref.type;

        var definition = cache.schema[type];
        var struct = cache.structs[type];
        contractMerge[action_name] = genMethod(type, definition, struct, contractMerge.transaction, code);
      });

      return contractMerge;
    });
  }

  function genMethod(type, definition, struct, transactionArg) {
    var code = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'eos';

    return function () {
      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      if (args.length === 0) {
        console.error(usage(type, definition, Network));
        return;
      }

      // Special case like multi-message transactions where this lib needs
      // to be sure the broadcast is off.
      var optionOverrides = {};
      var lastArg = args[args.length - 1];
      if ((typeof lastArg === 'undefined' ? 'undefined' : _typeof(lastArg)) === 'object' && _typeof(lastArg.__optionOverrides) === 'object') {
        // pop() fixes the args.length
        Object.assign(optionOverrides, args.pop().__optionOverrides);
      }

      var _processArgs2 = processArgs(args, Object.keys(definition.fields), type, optionsFormatter),
          params = _processArgs2.params,
          options = _processArgs2.options,
          returnPromise = _processArgs2.returnPromise,
          callback = _processArgs2.callback;

      // internal options (ex: multi-message transaction)


      Object.assign(options, optionOverrides);

      if (optionOverrides.noCallback && !returnPromise) {
        throw new Error('Callback during a transaction are not supported');
      }

      var addDefaultScope = options.scope == null;
      var addDefaultAuths = options.authorization == null;

      if (typeof options.scope === 'string') {
        options.scope = [options.scope];
      }

      var authorization = [];
      if (options.authorization) {
        if (typeof options.authorization === 'string') {
          options.authorization = [options.authorization];
        }
        options.authorization.forEach(function (auth) {
          if (typeof auth === 'string') {
            var _auth$split = auth.split('@'),
                _auth$split2 = _slicedToArray(_auth$split, 2),
                account = _auth$split2[0],
                _auth$split2$ = _auth$split2[1],
                permission = _auth$split2$ === undefined ? 'active' : _auth$split2$;

            authorization.push({ account: account, permission: permission });
          } else if ((typeof auth === 'undefined' ? 'undefined' : _typeof(auth)) === 'object') {
            authorization.push(auth);
          }
        });
        assert.equal(authorization.length, options.authorization.length, 'invalid authorization in: ' + JSON.stringify(options.authorization));
      }

      var tr = {
        scope: options.scope || [],
        messages: [{
          code: code,
          type: type,
          data: params,
          authorization: authorization
        }]
      };

      if (addDefaultScope || addDefaultAuths) {
        var fields = Object.keys(definition.fields);
        var f1 = fields[0];

        if (definition.fields[f1] === 'account_name') {
          if (addDefaultScope) {
            // Make a simple guess based on ABI conventions.
            tr.scope.push(params[f1]);
          }
          if (addDefaultAuths) {
            // Default authorization (since user did not provide one)
            tr.messages[0].authorization.push({
              account: params[f1],
              permission: 'active'
            });
          }
        }

        if (addDefaultScope) {
          if (fields.length > 1 && !/newaccount/.test(type)) {
            var f2 = fields[1];
            if (definition.fields[f2] === 'account_name') {
              tr.scope.push(params[f2]);
            }
          }
        }
      }

      tr.scope = tr.scope.sort();
      tr.messages[0].authorization.sort(function (a, b) {
        return a.account > b.account ? 1 : a.account < b.account ? -1 : 0;
      });

      // multi-message transaction support
      if (!optionOverrides.messageOnly) {
        transactionArg(tr, options, callback);
      } else {
        callback(null, tr);
      }

      return returnPromise;
    };
  }

  /**
    Wrap merge.functions adding optionOverrides that will suspend
    transaction broadcast.
  */
  function trMessageCollector(trCallback) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var merges = arguments[2];

    assert.equal('function', typeof trCallback === 'undefined' ? 'undefined' : _typeof(trCallback), 'trCallback');
    assert.equal('object', typeof options === 'undefined' ? 'undefined' : _typeof(options), 'options');
    assert.equal('object', typeof merges === 'undefined' ? 'undefined' : _typeof(merges), 'merges');
    assert(!Array.isArray(merges), 'merges should not be an array');
    assert.equal('function', typeof transaction === 'undefined' ? 'undefined' : _typeof(transaction), 'transaction');

    var scope = {};
    var messageList = [];
    var messageCollector = {};

    var wrap = function wrap(opFunction) {
      return function () {
        for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }

        // call the original function but force-disable a lot of stuff
        var ret = opFunction.apply(undefined, args.concat([{
          __optionOverrides: {
            broadcast: false,
            messageOnly: true,
            noCallback: true
          }
        }]));
        if (ret == null) {
          // double-check (code can change)
          throw new Error('Callbacks can not be used when creating a multi-message transaction');
        }
        messageList.push(ret);
      };
    };

    // merges can be an object of functions (as in the main eos contract)
    // or an object of contract names with functions under those
    for (var key in merges) {
      var value = merges[key];
      if (typeof value === 'function') {
        // Native operations (eos contract for example)
        messageCollector[key] = wrap(value);
      } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
        // other contract(s) (currency contract for example)
        if (messageCollector[key] == null) {
          messageCollector[key] = {};
        }
        for (var key2 in value) {
          if (key2 === 'transaction') {
            continue;
          }
          messageCollector[key][key2] = wrap(value[key2]);
        }
      }
    }

    var promiseCollector = void 0;
    try {
      // caller will load this up with messages
      promiseCollector = trCallback(messageCollector);
    } catch (error) {
      promiseCollector = Promise.reject(error);
    }

    return Promise.resolve(promiseCollector).then(function () {
      return Promise.all(messageList).then(function (resolvedMessageList) {
        var scopes = new Set();
        var messages = [];
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = resolvedMessageList[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var m = _step2.value;

            var _scope = m.scope,
                _m$messages = _slicedToArray(m.messages, 1),
                message = _m$messages[0];

            _scope.forEach(function (s) {
              scopes.add(s);
            });
            messages.push(message);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        var trObject = {};
        trObject.scope = Array.from(scopes).sort();
        trObject.messages = messages;
        return transaction(trObject, options);
      });
    });
  }

  function transaction(arg, options, callback) {
    var optionDefault = { expireInSeconds: 60, broadcast: true, sign: true };
    options = Object.assign({} /*clone*/, optionDefault, options);

    var returnPromise = void 0;
    if (typeof callback !== 'function') {
      returnPromise = new Promise(function (resolve, reject) {
        callback = function callback(err, result) {
          if (err) {
            reject(err);
          } else {
            resolve(result);
          }
        };
      });
    }

    if ((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) !== 'object') {
      throw new TypeError('First transaction argument should be an object or function');
    }

    if (!Array.isArray(arg.scope)) {
      throw new TypeError('Expecting scope array');
    }
    if (!Array.isArray(arg.messages)) {
      throw new TypeError('Expecting messages array');
    }

    if (config.transactionLog) {
      // wrap the callback with the logger
      var superCallback = callback;
      callback = function callback(error, tr) {
        if (error) {
          config.transactionLog(error);
        } else {
          config.transactionLog(null, tr);
        }
        superCallback(error, tr);
      };
    }

    arg.messages.forEach(function (message) {
      if (!Array.isArray(message.authorization)) {
        throw new TypeError('Expecting message.authorization array', message);
      }
    });

    if (options.sign && typeof config.signProvider !== 'function') {
      throw new TypeError('Expecting config.signProvider function (disable using {sign: false})');
    }

    network.createTransaction(options.expireInSeconds, checkError(callback, function (rawTx) {
      rawTx.scope = arg.scope;
      rawTx.messages = arg.messages;
      // rawTx.read_scope = arg.read_scope || []

      // console.log('rawTx', JSON.stringify(rawTx,null,4))

      // resolve shorthand
      // const txObject = Transaction.toObject(Transaction.fromObject(rawTx))
      var txObject = Transaction.fromObject(rawTx);

      // console.log('txObject', JSON.stringify(txObject,null,4))

      // Broadcast what is signed (instead of rawTx)
      var buf = Fcbuffer.toBuffer(Transaction, txObject);
      var tr = Fcbuffer.fromBuffer(Transaction, buf);

      var transactionId = createHash('sha256').update(buf).digest().toString('hex');

      var sigs = [];
      if (options.sign) {
        var chainIdBuf = new Buffer(config.chainId, 'hex');
        var signBuf = Buffer.concat([chainIdBuf, buf]);
        sigs = config.signProvider({ transaction: tr, buf: signBuf, sign: sign });
        if (!Array.isArray(sigs)) {
          sigs = [sigs];
        }
      }

      // sigs can be strings or Promises
      Promise.all(sigs).then(function (sigs) {
        sigs = [].concat.apply([], sigs); //flatten arrays in array
        tr.signatures = sigs;

        if (!options.broadcast) {
          callback(null, {
            transaction_id: transactionId,
            broadcast: false,
            transaction: tr
          });
        } else {
          network.pushTransaction(tr, function (error) {
            if (!error) {
              callback(null, {
                transaction_id: transactionId,
                broadcast: true,
                transaction: tr
              });
            } else {
              console.error('[push_transaction error] \'' + error.message + '\', digest \'' + buf.toString('hex') + '\'');
              callback(error.message);
            }
          });
        }
      }).catch(function (error) {
        console.error(error);
        callback(error);
      });
    }));
    return returnPromise;
  }

  // return WriteApi
  return {
    genTransaction: genTransaction,
    genContractActions: genContractActions,
    genMethod: genMethod
  };
}

var isStringArray = function isStringArray(o) {
  return Array.isArray(o) && o.length > 0 && o.findIndex(function (o) {
    return typeof o !== 'string';
  }) === -1;
};

// Normalize the extra optional options argument
var optionsFormatter = function optionsFormatter(option) {
  if ((typeof option === 'undefined' ? 'undefined' : _typeof(option)) === 'object') {
    return option; // {debug, broadcast, scope, etc} (scope, etc my overwrite tr below)
  }
  if (typeof option === 'boolean') {
    // broadcast argument as a true false value, back-end cli will use this shorthand
    return { broadcast: option };
  }
};

function usage(type, definition, Network) {
  var _Structs = Structs({ defaults: true, network: Network }),
      structs = _Structs.structs;

  var struct = structs[type];

  if (struct == null) {
    throw TypeError('Unknown type: ' + type);
  }

  var usage = '';
  var out = function out() {
    var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

    usage += str + '\n';
  };
  out('' + type);
  out();

  out('USAGE');
  out('' + JSON.stringify(definition, null, 4));
  out();

  out('EXAMPLE STRUCTURE');
  out('' + JSON.stringify(struct.toObject(), null, 4));

  return usage;
}

var checkError = function checkError(parentErr, parrentRes) {
  return function (error, result) {
    if (error) {
      console.log('error', error);
      parentErr(error);
    } else {
      parrentRes(result);
    }
  };
};