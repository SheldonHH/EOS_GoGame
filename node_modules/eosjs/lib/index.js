'use strict';

var ecc = require('eosjs-ecc');
var json = require('eosjs-json');
var Fcbuffer = require('fcbuffer');
var api = require('eosjs-api');

var Structs = require('./structs');
var AbiCache = require('./abi-cache');
var writeApiGen = require('./write-api');
var assert = require('assert');

var Eos = {};

module.exports = Eos;

Eos.modules = {
  json: json,
  ecc: ecc,
  api: api,
  Fcbuffer: Fcbuffer

  // Eos.Mainnet = config => ..

};Eos.Testnet = function (config) {
  var Network = api.Testnet;
  var network = Network(Object.assign({}, { apiLog: consoleObjCallbackLog }, config));
  var eosConfig = Object.assign({}, { transactionLog: consoleObjCallbackLog }, config);
  return createEos(eosConfig, Network, network);
};

function createEos(config, Network, network) {
  var abiCache = AbiCache(network, config);
  config = Object.assign({}, config, { network: network, abiCache: abiCache });

  if (!config.chainId) {
    config.chainId = '00'.repeat(32);
  }

  var eos = mergeWriteFunctions(config, Network);

  if (!config.signProvider) {
    config.signProvider = defaultSignProvider(eos, config);
  }

  return eos;
}

function consoleObjCallbackLog(error, result, name) {
  if (error) {
    if (name) {
      console.error(name, 'error');
    }
    console.error(error);
  } else {
    if (name) {
      console.log(name, 'reply:');
    }
    console.log(JSON.stringify(result, null, 4));
  }
}

/**
  Merge in write functions (operations).  Tested against existing methods for
  name conflicts.

  @arg {object} config.network - read-only api calls
  @arg {object} Network - api[Network] read-only api calls
  @return {object} - read and write method calls (create and sign transactions)
  @throw {TypeError} if a funciton name conflicts
*/
function mergeWriteFunctions(config, Network) {
  assert(config.network, 'network instance required');

  var network = config.network;

  var _Structs = Structs(config),
      structs = _Structs.structs,
      types = _Structs.types;

  var merge = Object.assign({}, { fc: { structs: structs, types: types } });

  throwOnDuplicate(merge, network, 'Conflicting methods in Eos and Network Api');
  Object.assign(merge, network);

  var writeApi = writeApiGen(Network, network, structs, config);
  throwOnDuplicate(merge, writeApi, 'Conflicting methods in Eos and Transaction Api');
  Object.assign(merge, writeApi);

  return merge;
}

function throwOnDuplicate(o1, o2, msg) {
  for (var key in o1) {
    if (o2[key]) {
      throw new TypeError(msg + ': ' + key);
    }
  }
}

var defaultSignProvider = function defaultSignProvider(eos, config) {
  return function (_ref) {
    var sign = _ref.sign,
        buf = _ref.buf,
        transaction = _ref.transaction;

    var keyProvider = config.keyProvider;
    if (typeof keyProvider === 'function') {
      keyProvider = keyProvider({ transaction: transaction });
    }
    if (keyProvider) {
      return Promise.resolve(keyProvider).then(function (keys) {
        if (!Array.isArray(keys)) {
          keys = [keys];
        }

        if (!keys.length) {
          throw new Error('missing private key(s), check your keyProvider');
        }

        // Public to private key map -> maps server's required public keys
        // back to signing keys.
        var keyMap = keys.reduce(function (map, wif) {
          map[ecc.privateToPublic(wif)] = wif;
          return map;
        }, {});

        return eos.getRequiredKeys(transaction, Object.keys(keyMap)).then(function (_ref2) {
          var required_keys = _ref2.required_keys;

          if (!required_keys.length) {
            throw new Error('missing required keys ');
          }
          var sigs = [];
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = required_keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var key = _step.value;

              sigs.push(sign(buf, keyMap[key]));
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          return sigs;
        });
      });
    }
    throw new TypeError('This transaction requires a config.keyProvider for signing');
  };
};